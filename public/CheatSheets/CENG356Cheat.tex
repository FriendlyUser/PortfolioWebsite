%% Manually modify after exams or before the test hits me
\chapter{CENG356}
\textbf{Increm­ental vs Iterative}

\begin{longtable}[]{@{}ll@{}}
	\toprule
	Increm­ental & Iterative\tabularnewline
	\midrule
	\endhead
	1. The requir­ements are divided into different builds & 1. Does not
	start with a full specif­ication\tabularnewline
	2. Needs a clear and complete definition of the whole system from the
	start & 2. Building and improving the product step by
	step\tabularnewline
	3. Customers can respond to each build (but a build may not represent
	the whole system) & 3. We can get reliable user feedback\tabularnewline
	4. Increm­ental fundam­entally means~\textbf{add onto}~and helps you to
	improve your~\textbf{proc­ess} & 4. Good for big projects\tabularnewline
	~ & 5. Only major reqs. can be defined, details may evolve over
	time\tabularnewline
	~ & 6. Iterative fundam­entally means~\textbf{redo}~and helps you to
	improve you~\textbf{prod­uct}\tabularnewline
	\bottomrule
\end{longtable}

\textbf{Protot­yping}\label{prototyping}

\begin{longtable}[]{@{}l@{}}
	\toprule
	\vtop{\hbox{\strut \textbf{Types of
				Protot­ypes:}}\hbox{\strut \emph{Throw­away}~= Example is a paper one.
			Will be used only for evalua­tion;~\emph{Incre­mental}~= created a
			separate compon­ents;~\emph{Evolu­tio­nary}~= refined to become actual
			product}\hbox{\strut \textbf{Prot­otype
				Fideli­ty:}}\hbox{\strut \emph{Low}~= Omit details (Rough, no code, easy
			to trash) - Paper, Storyb­oard, Wizard of OZ (evalu­ation)~\emph{High}~=
			Looks like a polished product (looks of product, comment on aesthe­tics,
			GUI powerpoint etc are used)}\hbox{\strut \textbf{Prot­otyping can help
				answer:}}\hbox{\strut - Crowded UI, Knobs versu slider for contro­lling
			volume, Navigation = Transp­arent or solid menu?}}\tabularnewline
	\bottomrule
\end{longtable}

\textbf{White Box/Black Box
	Testing}\label{white-boxblack-box-testing}

\begin{longtable}[]{@{}l@{}}
	\toprule
	\vtop{\hbox{\strut \textbf{White}~= AKA glass box, struct­ural; Tester
			know the source code and can debug at runtime = Develo­per's
			perspe­ctive}\hbox{\strut \textbf{Unit Testing}~= Do discrete parts of
			my system work as expected?}\hbox{\strut - Does an individual method
			work as expected?}\hbox{\strut - Necessary calls to other methods should
			be mocked out where possible}\hbox{\strut -Always white
			box}\hbox{\strut \textbf{Black}~= Tester gives inputs and observe
			outputs (No code, only focus on reqs., interacts with UI only) = User's
			perspe­ctive}\hbox{\strut \textbf{Acce­ptance Testing}~= Is the system
			working from the customer's perspe­­ctive? (AKA. System
			testing)}\hbox{\strut - Interacts with system through GUI}\hbox{\strut -
			Focused in feature~}\hbox{\strut Usually black box}}\tabularnewline
	\bottomrule
\end{longtable}

White = Did we build the system right?\\
Black = Did we build the right system?

\textbf{Agile vs TDD}\label{agile-vs-tdd}

\begin{longtable}[]{@{}l@{}}
	\toprule
	\vtop{\hbox{\strut \textbf{TDD}~= focused on how code gets written (for
			work cycles of indivi­duals or small groups of developers
			exclus­ively)}\hbox{\strut \textbf{Agile}~= Overall develo­pment process
			(focuses on project management and groups of develo­pers, as opposed to
			specif­ically how a given developer writes code)}}\tabularnewline
	\bottomrule
\end{longtable}

\textbf{Polymo­rphism}\label{polymorphism}

\begin{longtable}[]{@{}l@{}}
	\toprule
	A property of OO software by which an abstract operation may be
	performed in different ways, typically in different
	classes.\tabularnewline
	\bottomrule
\end{longtable}

\textbf{Inheri­tance}\label{inheritance}

\begin{longtable}[]{@{}l@{}}
	\toprule
	Implicit possession by a subclass of features defined in a subclass.
	Features include variables and methods\tabularnewline
	\bottomrule
\end{longtable}

\textbf{Abstract Classes and Abstract
	Operations}\label{abstract-classes-and-abstract-operations}

\begin{longtable}[]{@{}ll@{}}
	\toprule
	Abstract Operations & No method for that operation exists in the
	class\tabularnewline
	\midrule
	\endhead
	Abstract Class & Cannot have any instances\tabularnewline
	\bottomrule
\end{longtable}

- A class that has one or more abstract more abstract methods must be
declared abstract.\\
- Any class, except a leaf class, can be declared abstract\\
- Label with \textless{}ab­str­act\textgreater{}

\textbf{Sturctural Modelling}\label{sturctural-modelling}

\begin{longtable}[]{@{}l@{}}
	\toprule
	\textbf{Gene­ral­iza­tion:}~Specia­lizing a superclass into subcla­sses.
	Avoid unnece­ssary genera­liz­ations\tabularnewline
	\midrule
	\endhead
	\textbf{Depe­nde­ncy:}~Used for extremely weak relati­­on­ships between
	classes. Ex. A class makes use of a library\tabularnewline
	\textbf{Aggr­ega­tion:}~Represents "­par­t-w­hol­e" relati­ons­hips. The
	whole side is called the aggregate. Aggreg­ations are read as "is part
	of"\tabularnewline
	\textbf{Comp­osi­tion:}~Are strong forms of aggreg­ation. If the
	aggregate is destroyed, then the parts are also
	destroyed.\tabularnewline
	\bottomrule
\end{longtable}

\textbf{Aggr­ega­tion}~= An associ­ation is an aggreg­ation if: the
parts 'are part of' the aggregate. The aggregate 'is composed of' the
parts. When something owns or controls the aggregate, then they also own
and control the parts

\textbf{Software Archit­ecture}\label{software-architecture}

\begin{longtable}[]{@{}l@{}}
	\toprule
	Process of designing the global organi­zation of a software system
	including:\tabularnewline
	\midrule
	\endhead
	- Dividing software into subsystems - Deciding how these will interact -
	Determ­ining their interf­aces: the archit­ecture is the core of the
	design so all software engineers must understand it. Archit­ecture will
	often constrain the overall effici­ency, reusab­ility and
	mainta­ina­bility of the system\tabularnewline
	Import­ance: To enable everyone to better understand the system, To
	allow people to work on individual pieces of the system in isolation,
	prepare for extension of the system, facilitate reuse and
	reusab­ility\tabularnewline
	Archit­ecture in different views:\tabularnewline
	- Logical breakdown into subsys­tems, - Interfaces among the
	subsys­tems, - Dynamics of the intera­ction among components at run
	time, - Data will be shared among subsys­tems, - Components will exist
	at run time and the machines or devices on which they will be located,
	-\tabularnewline
	Ensuring mainta­ina­bility and reliab­ility = archit­ectural model is
	stable\tabularnewline
	- Stable = means new features can be easily added with only small
	changes to the archit­ecture\tabularnewline
	\bottomrule
\end{longtable}

\textbf{Agile vs. Spiral}\label{agile-vs.-spiral}

\begin{longtable}[]{@{}ll@{}}
	\toprule
	Agile & Spiral\tabularnewline
	\midrule
	\endhead
	Iterations are shorter (1 to 4 weeks) & Iterations are longer (4 to 6
	months)\tabularnewline
	Not good for low rates of requir­ements change (cost of collab­ora­tion)
	& Suitable for large scale develo­pment (due to risk
	analysis)\tabularnewline
	Is good for low-risk and less critical systems & More emphasis on
	docume­ntation and process\tabularnewline
	\bottomrule
\end{longtable}

Both are increm­ental and iterative

\textbf{Static vs Dynamic
	Testing}\label{static-vs-dynamic-testing}

\begin{longtable}[]{@{}llll@{}}
	\toprule
	Static & Dynamic & Validation & Verifi­cation\tabularnewline
	\midrule
	\endhead
	Objective = Finding errors in early stages of the develo­pment cycle &
	Objective = Checks the functional behaviour of the system & Check that
	the software product meets the customer's actual needs & Whether the
	system is well-e­ngi­neered? Error free?\tabularnewline
	Are we building the product right? & Are we building the right product?
	& Dynamic & Static\tabularnewline
	Activities = Reviews, Walkth­roughs, Inspection & Testing - The product
	meets the user's needs = the product fulfills its intended
	use\tabularnewline
	The product is built according to the reqs.\tabularnewline
	\bottomrule
\end{longtable}

Checking whether the software is of high quality will not ensure that
the system is useful. So~\textbf{Trust but verify, verify but also
	valida­te}.

\textbf{Race Conditions}\label{race-conditions}

\begin{longtable}[]{@{}l@{}}
	\toprule
	A race occurs when two threads are using the same resources and the
	order of operations is important\tabularnewline
	\midrule
	\endhead
	Critical races can be prevented by locking data so they cannot be
	accessed by other threads\tabularnewline
	Ex. A keyword like~\emph{synch­ron­ized}\tabularnewline
	\bottomrule
\end{longtable}

\textbf{Testing Strate­gies}\\
- Hard to test critical races\\
- Use mocking to control the order

\textbf{UML Diagrams}\label{uml-diagrams}

\begin{longtable}[]{@{}l@{}}
	\toprule
	\textbf{Inte­raction Diagra­ms:}~A set of diagrams to model the dynamic
	aspects of the system. To visualize how the system runs. Often built
	from a use case and class diagram to illustrate how a set of objects
	accomplish the required intera­ctions with an actor.\tabularnewline
	\midrule
	\endhead
	\textbf{Sequence Diagra­ms:}~An intera­ction diagram that focuses on the
	sequence of messages exchanged by a set of objects performing a certain
	task\tabularnewline
	\textbf{Comm­uni­cation Diagra­ms:}~Emphasize how objects collab­orate
	to realize an intera­ction\tabularnewline
	\textbf{State Diagrams}~At any given point in time, the system is in
	precisely one state and will remain in the state until an event occurs
	to change state. Is a directed graph, nodes are states, edges are
	transi­tions. Have timeouts to automa­tically change
	states\tabularnewline
	\bottomrule
\end{longtable}

\textbf{Inte­raction Diagrams Show (Inter­act­ion)}~= the steps of the
use case, the steps of a piece of functi­ona­lity. Composed of instances
of classes, actors and messages.~\\
\textbf{Sequence Diagra­ms:}~Can represent condit­ional logic and loops
and show explicit destru­ction of objects.\\
\textbf{Comm­uni­cation Diagram:}~Annota­tions of object diagrams. Shows
link between objects that commun­icate

\textbf{Functional vs.
	Non-fu­nct­ional}\label{functional-vs.-non-functional}

\begin{longtable}[]{@{}ll@{}}
	\toprule
	Functional & What is the system doing? For example: Should be able to
	make two slides\tabularnewline
	\midrule
	\endhead
	Non Functional & How is the system doing a thing? For Ex. A created
	slide should be displayed in 1 second\tabularnewline
	\bottomrule
\end{longtable}

\textbf{Non - Functional}\label{non---functional}

\begin{longtable}[]{@{}l@{}}
	\toprule
	Response Time, Throug­hput, Resource Usage, Reliab­ility, Availa­bility,
	Failure Recovery, Mainta­ina­bility, Modula­rity, Security,
	Testab­ility, Learna­bility, Usability, Price, Extens­ibi­lity,
	Reusab­ility\tabularnewline
	\bottomrule
\end{longtable}

Non functional requir­ements may be more critical than functional
requir­ements, if these are not met, the system is useless! Usually
cannot be implem­ented in a single module of a program.

\textbf{The Process of Design}\label{the-process-of-design}

\begin{longtable}[]{@{}l@{}}
	\toprule
	\vtop{\hbox{\strut \textbf{Design}~= problem solving process to find and
			describe a way:}\hbox{\strut - to implement the system's functional
			reqs.~}\hbox{\strut - respect the constr­aints imposed by
			non-fu­nct­ional reqs. (budget, deadli­nes..)}\hbox{\strut - adhere to
			general principles of good quality}\hbox{\strut \textbf{Design Issues}~=
			sub problems of the overall design. Each issue has several altern­ative
			solutions. The designer makes a design decision to resolve each issue.
			This involves choosing what he or she consider to be the best option
			from among the altern­atives.~}\hbox{\strut \textbf{Good design}~=
			increasing profit with reduced cost, ensure confor­mation to the reqs.,
			accele­rating develo­pment, increasing usability, effici­ency,
			reliab­ility, mainta­ina­bility and reusab­ility}}\tabularnewline
	\bottomrule
\end{longtable}

They use knowledge of the reqs., the design created so far, the tech.
available, software design principles and 'best practices' and past
experi­ences.